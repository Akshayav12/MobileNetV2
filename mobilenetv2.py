# -*- coding: utf-8 -*-
"""Mobilenetv2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ioC07D1-x78efLrrEjvDI1Ye-h9LF5he
"""

from google.colab import drive
drive.mount('/content/drive')

import os

# Path to the ZIP file
zip_path = "/content/drive/MyDrive/archive.zip"  # Update with your actual file path
extract_path = "/content/dataset"  # Target directory for extraction

# Unzip the file
os.system(f"unzip -q {zip_path} -d {extract_path}")
print(f"âœ… Dataset extracted to: {extract_path}")

import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.applications import ResNet50, VGG16, EfficientNetB0, MobileNetV2
from tensorflow.keras.layers import Dense, Flatten, GlobalAveragePooling2D
from tensorflow.keras.models import Model
import matplotlib.pyplot as plt
import numpy as np

# Define dataset path
dataset_path = "/content/dataset/Segmented Medicinal Leaf Images"

# Image settings
IMAGE_SIZE = (224, 224)
BATCH_SIZE = 32

# Data Augmentation & Loading
datagen = ImageDataGenerator(rescale=1./255, validation_split=0.2)

train_generator = datagen.flow_from_directory(
    dataset_path,
    target_size=IMAGE_SIZE,
    batch_size=BATCH_SIZE,
    class_mode='categorical',
    subset='training')

val_generator = datagen.flow_from_directory(
    dataset_path,
    target_size=IMAGE_SIZE,
    batch_size=BATCH_SIZE,
    class_mode='categorical',
    subset='validation')

# Number of classes
num_classes = len(train_generator.class_indices)

# Function to create models
def create_model(base_model):
    base_model.trainable = False  # Freeze the convolutional base
    x = base_model.output
    x = GlobalAveragePooling2D()(x)
    x = Dense(128, activation='relu')(x)
    output = Dense(num_classes, activation='softmax')(x)
    model = Model(inputs=base_model.input, outputs=output)
    model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
    return model

# Define models
models = {
    "MobileNetV2": create_model(MobileNetV2(weights='imagenet', include_top=False, input_shape=IMAGE_SIZE + (3,)))

}

# Training all models
history_dict = {}
for name, model in models.items():
    print(f"Training {name}...")
    history = model.fit(train_generator, validation_data=val_generator, epochs=10)
    model.save(f"{name}_model.h5")
    history_dict[name] = history

# Plot accuracy comparison
plt.figure(figsize=(12, 6))
for name, history in history_dict.items():
    plt.plot(history.history['accuracy'], label=f'{name} Train')
    plt.plot(history.history['val_accuracy'], label=f'{name} Val')
plt.title('Model Accuracy Comparison')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend()
plt.show()

# Evaluate models
for name, model in models.items():
    loss, accuracy = model.evaluate(val_generator)
    print(f"{name} - Accuracy: {accuracy * 100:.2f}% | Loss: {loss:.4f}")

import numpy as np
import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from sklearn.metrics import classification_report

# Load the trained MobileNetV2 model
model = tf.keras.models.load_model('/content/MobileNetV2_model.h5')

# Define test dataset directory
test_dir = '/content/dataset/Segmented Medicinal Leaf Images'

# Preprocessing function for MobileNetV2
def preprocess_image(img):
    img = tf.keras.preprocessing.image.img_to_array(img)
    img = tf.keras.applications.mobilenet_v2.preprocess_input(img)
    return img

# Load test dataset
test_datagen = ImageDataGenerator(preprocessing_function=preprocess_image)
test_generator = test_datagen.flow_from_directory(
    test_dir,
    target_size=(224, 224),
    batch_size=32,
    class_mode='categorical',
    shuffle=False
)

# Get true labels
true_labels = test_generator.classes
class_names = list(test_generator.class_indices.keys())

# Get model predictions
predictions = model.predict(test_generator)
predicted_labels = np.argmax(predictions, axis=1)

# Print classification report
report = classification_report(true_labels, predicted_labels, target_names=class_names)
print(report)

import numpy as np
import tensorflow as tf
from tensorflow.keras.preprocessing import image
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score

# Load the trained MobileNetV2 model
model = tf.keras.models.load_model('/content/MobileNetV2_model.h5')

# Define test dataset directory
test_dir = '/content/dataset/Segmented Medicinal Leaf Images'

# Load test dataset
test_datagen = ImageDataGenerator(preprocessing_function=tf.keras.applications.mobilenet_v2.preprocess_input)
test_generator = test_datagen.flow_from_directory(
    test_dir,
    target_size=(224, 224),
    batch_size=32,
    class_mode='categorical' if model.output_shape[-1] > 1 else 'binary',
    shuffle=False
)

# Get class labels dynamically
class_labels = list(test_generator.class_indices.keys())
print("Detected Classes:", class_labels)  # Debugging

# Get true labels
true_labels = test_generator.classes

# Get model predictions
predictions = model.predict(test_generator)
predicted_labels = np.argmax(predictions, axis=1) if model.output_shape[-1] > 1 else (predictions > 0.5).astype(int).flatten()

# Calculate metrics
accuracy = accuracy_score(true_labels, predicted_labels)
precision = precision_score(true_labels, predicted_labels, average='weighted')
recall = recall_score(true_labels, predicted_labels, average='weighted')
f1 = f1_score(true_labels, predicted_labels, average='weighted')

# Print classification results
print(f'Accuracy: {accuracy:.4f}')
print(f'Precision: {precision:.4f}')
print(f'Recall: {recall:.4f}')
print(f'F1 Score: {f1:.4f}')

# Function to predict if a leaf is medicinal or not
def predict_leaf(img_path):
    img = image.load_img(img_path, target_size=(224, 224))
    img = image.img_to_array(img)
    img = np.expand_dims(img, axis=0)
    img = tf.keras.applications.mobilenet_v2.preprocess_input(img)

    prediction = model.predict(img)

    # Predict class correctly based on model type
    if model.output_shape[-1] == 1:  # Binary classification
        predicted_class = int(prediction[0][0] > 0.5)
    else:  # Multi-class classification
        predicted_class = np.argmax(prediction[0])

    result = class_labels[predicted_class]  # Avoid index error
    print(f'Predicted Class: {result}')
    return result

# Test with a single image
image_path = '/content/dataset/Segmented Medicinal Leaf Images/Tulsi/OT-S-047.jpg'  # Update with actual image path
predict_leaf(image_path)